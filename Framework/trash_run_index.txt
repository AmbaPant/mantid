./MDAlgorithms/test/MDEventWSWrapperTest.h:73:    std::vector<uint16_t> run_index(n_MDev, 2);
./MDAlgorithms/test/MDEventWSWrapperTest.h:78:                              pWSWrap->addMDData(sig_err, run_index, goniometer_index, det_ids, allCoord, n_MDev));
./MDAlgorithms/test/ConvertToMDComponentsTest.h:250:    TS_ASSERT_THROWS_NOTHING(expInfoIndex = targWSDescr.getPropertyValueAsType<uint16_t>("RUN_INDEX"));
./MDAlgorithms/test/ConvertToMDTest.h:547:    WSD.addProperty("RUN_INDEX", static_cast<uint16_t>(10), true);
./MDAlgorithms/test/ConvertToMDTest.h:581:    WSD.addProperty("RUN_INDEX", static_cast<uint16_t>(10), true);
./MDAlgorithms/test/ConvertToMDTest.h:617:    WSD.addProperty("RUN_INDEX", static_cast<uint16_t>(10), true);
./MDAlgorithms/test/ConvertToMDTest.h:655:    WSD.addProperty("RUN_INDEX", static_cast<uint16_t>(10), true);
./MDAlgorithms/src/ConvToMDBase.cpp:52:  m_RunIndex = WSD.getPropertyValueAsType<uint16_t>("RUN_INDEX");
./MDAlgorithms/src/ConvToMDEventsWS.cpp:39:  std::vector<uint16_t> run_index;        // Buffer for run index for each event
./MDAlgorithms/src/ConvToMDEventsWS.cpp:45:  run_index.reserve(numEvents);
./MDAlgorithms/src/ConvToMDEventsWS.cpp:65:    run_index.emplace_back(expInfoIndexLoc);
./MDAlgorithms/src/ConvToMDEventsWS.cpp:72:  size_t n_added_events = run_index.size();
./MDAlgorithms/src/ConvToMDEventsWS.cpp:73:  m_OutWSWrapper->addMDData(sig_err, run_index, goniometer_index, det_ids, allCoord, n_added_events);
./MDAlgorithms/src/ConvertToMD.cpp:326:  targWSDescr.addProperty("RUN_INDEX", expInfoIndex, true);
./MDAlgorithms/src/ConvToMDHistoWS.cpp:67:  std::vector<uint16_t> run_index(m_bufferSize);        // Buffer run index for each event
./MDAlgorithms/src/ConvToMDHistoWS.cpp:129:      run_index[nBufEvents] = m_RunIndex;
./MDAlgorithms/src/ConvToMDHistoWS.cpp:139:        m_OutWSWrapper->addMDData(sig_err, run_index, goniometer_index, det_ids, allCoord, nBufEvents);
./MDAlgorithms/src/ConvToMDHistoWS.cpp:149:    m_OutWSWrapper->addMDData(sig_err, run_index, goniometer_index, det_ids, allCoord, nBufEvents);
./MDAlgorithms/src/ConvertToMDMinMaxLocal.cpp:86:  targWSDescr.addProperty("RUN_INDEX", uint16_t(0), true);
./MDAlgorithms/inc/MantidMDAlgorithms/ConvToMDEventsWSIndexing.h:73:    static MDEventType<ND> makeMDEvent(const double &sig, const double &err, const uint16_t &run_index,
./MDAlgorithms/inc/MantidMDAlgorithms/ConvToMDEventsWSIndexing.h:75:      return MDEventType<ND>(sig, err, run_index, goniometer_index, det_id, coord);
./MDAlgorithms/inc/MantidMDAlgorithms/MDEventWSWrapper.h:107:  void addAndTraceMDDataND(float *sig_err, uint16_t *run_index, uint16_t *goniometerIndex, uint32_t *det_id,
./PythonInterface/mantid/api/src/Exports/MultipleExperimentInfos.cpp:20:           (arg("self"), arg("run_index")), "Return the experiment info at the given index.")
./PythonInterface/plugins/algorithms/LRScalingFactors.py:242:    def get_attenuators(self, workspace, run_index):
./PythonInterface/plugins/algorithms/LRScalingFactors.py:245:            @param run_index: index of the run in case we are getting the attenuators from the input properties
./PythonInterface/plugins/algorithms/LRScalingFactors.py:248:            return self.attenuators[run_index]
./PythonInterface/test/python/plugins/algorithms/VesuvioTOFFitTest.py:67:    def test_single_run_index0_kfixed_no_background_with_ties(self):
./DataObjects/test/WorkspaceCreationTest.h:95:void run_indexInfo_legacy_compatibility_partitioned_workspace_failure(const Parallel::Communicator &comm) {
./DataObjects/test/WorkspaceCreationTest.h:488:    run_indexInfo_legacy_compatibility_partitioned_workspace_failure(Parallel::Communicator{});
./DataObjects/test/WorkspaceCreationTest.h:493:    runner.run(run_indexInfo_legacy_compatibility_partitioned_workspace_failure);
./DataObjects/inc/MantidDataObjects/MDEvent.h:24: *   - 16-bit int for the run_index (index into the vector of ExperimentInfo of
./Crystal/src/FindUBUsingIndexedPeaks.cpp:122:        size_t run_indexed = 0;
./Crystal/src/FindUBUsingIndexedPeaks.cpp:128:              run_indexed++;
./Crystal/src/FindUBUsingIndexedPeaks.cpp:132:        g_log.notice() << "Number of Indexed Peaks in Run " << run << " is " << run_indexed << "\n";
./Crystal/src/FindUBUsingIndexedPeaks.cpp:134:        run_q_vectors.reserve(run_indexed);
./Crystal/src/FindUBUsingIndexedPeaks.cpp:135:        run_hkl_vectors.reserve(run_indexed);
./Crystal/src/FindUBUsingIndexedPeaks.cpp:136:        run_mnp_vectors.reserve(run_indexed);
./Crystal/src/FindUBUsingIndexedPeaks.cpp:137:        run_fhkl_vectors.reserve(run_indexed);
./Crystal/src/FindUBUsingIndexedPeaks.cpp:152:        if (run_indexed < 3)
./Crystal/src/FindUBUsingIndexedPeaks.cpp:165:        for (size_t i = 0; i < run_indexed; i++) {
